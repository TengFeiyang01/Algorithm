

# T1

## 题面

给定一个 32 位的符号整数，按位反转，输出其反转的结果

```
一个整数
```

输出描述

```
其反转的结果
```

注意：

```
32 位整数的表示范围为[-2^31,2^31-1].如果反转后的数溢出，请返回 0
```

> 输入:
>
> 123
>
> 输出:
>
> 321

>输入：
>
>-123
>
>输出：
>
>-321
>
>输入：
>
>120
>
>输出：
>
>21

## 思路

直接模拟即可，注意判断是否会整数溢出。


## 代码

```cpp
#include <bits/stdc++.h>

const int inf = 0x3f3f3f3f;
using i64 = long long;

void solve() {
	int x;
	std::cin >> x;
    int rev = 0;
    while (x != 0) {
        if (rev < INT_MIN / 10 || rev > INT_MAX / 10) {
            return 0;
        }
        int digit = x % 10;
        x /= 10;
        rev = rev * 10 + digit;
    }
    std::cout << rev << "\n";
}
    

int main() {
    std::cin.sync_with_stdio(false);
    std::cin.tie(0);
    
    solve();

    return 0;
}
```



# T2

## 题面

给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A-Z字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在1个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。然而，两个相同种类的任务之间必须有长度为M 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。

输入描述

```
第一行为整数N(1 <= N<= 10000),代表共有多少个任务;第二行为长度为 N 的字符串T，代表每个任务的种类; 第三行为 M (0<= M<=100),代表相同任务的冷却时间。
```

输出描述

```
完成所有任务的最短时间
```

>输入:
>
>N=2
>T="AB"
>M=2
>
>输出:
>
>2

## 思路

先考虑最为简单的情况：假设只有一类任务，除了最后一个任务以外，其余任务在安排后均需要增加 $n$ 个单位的冻结时间。

将任务数记为 $m$ 个，其中前 $m−1$ 个任务均要消耗 $n+1$ 的单位时间，最后一个任务仅消耗 $1$ 个单位时间，即所需要的时间为 $(n+1)×(m−1)+1$。

当存在多个任务时，由于每一类任务都需要被完成，因此本质上我们最需要考虑的是将数量最大的任务安排掉，其他任务则是间插其中。

假设数量最大的任务数为 max，共有 tot 个任务数为 max 的任务种类。

实际上，当任务总数不超过 $(n + 1) \times (\max - 1) + tot$ 时，我们总能将其他任务插到空闲时间中去，不会引入额外的冻结时间；而当任务数超过该值时，我们可以在将其横向添加每个 $n + 1$​ 块的后面，同时不会引入额外的冻结时间：

综上，我们所需要的最小时间为上述两种情况中的较大值即可：

$$
\max(n, (m + 1) \times (max - 1) + tot)
$$


## 代码

```cpp
#include <bits/stdc++.h>

const int inf = 0x3f3f3f3f;
using i64 = long long;

void solve() {
    int n, m;
    std::string s;
    std::cin >> n >> s >> m;
    std::vector<int> count(26);
    for (auto c : s) 
        ++count[c - 'A'];
    int max_t = *std::max_element(count.begin(), count.end());
    int cnt = 0;
    for (auto&&num : count) 
        cnt += (num == max_t);
    std::cout << std::max(n, (max_t - 1) * (m + 1) + cnt) << "\n";
}

int main() {
    std::cin.sync_with_stdio(false);
    std::cin.tie(0);
    
    solve();

    return 0;
}
```



# T3

## 题面

新的学期准备开始了，小文最近正在为选课问题而烦恼不已，希望聪明的你可以帮他解决这个问题。小文从教务系统上得到了所有课程的开课信息，表示如下:(t1，t2，value )，对于每一门课的上课会在[t1，t2)时间段进行，由于小文不是神仙，没办法同一时间上多门课，所以如果课程的时间有冲突，则必须在这些课中进行取舍。t1，t2均为整数，不同的课对小文的作用不同，有些比较重要有些则没那么重要，课程的价值用一个大于零的正整数value来表示。那么小文怎么选课，才能保证课程之间不冲突，并且可以上的课可以获得最大的价值。

输入描述

```
第一行为整数 n，表示有多少门课，0<n<=1000000，之后是n行二维数组T，第i行 t1，t2， value，表示第i门课的开始时间，结束时间和该课程的价值(0<t1<t2<=100000000)0<=value<=100000000
```

输出描述

```
一个整数 max_value，表示小文可以得到的最大价值
```

>输入:
>
>n= 3
>
>T=[[1, 10, 10],
>
>[3, 4, 11].
>
>[4, 5, 3]]
>
>输出:
>
>14

## 思路

我们可以分类讨论，求出按照结束时间排序后的前 i 个课程的最大价值：

- 不选第 i 个课程，那么最大报酬等于前 i−1 个课程的最大报酬（转换成了一个规模更小的子问题）；
- 选第 i 个工作，由于工作时间不能重叠，设 j 是最大的满足 $T[j][1] < T[i][1]$ 的 j，那么最大报酬等于前 j 个工作的最大报酬加上 $T[i][2]$（同样转换成了一个规模更小的子问题）；

这两种决策取最大值。

注：由于按照结束时间排序，前 j 个课程中的任意一个都不会与第 i 个课程的时间重叠。

定义 f[i] 表示按照结束时间排序后的前 i 个课程 的最大报酬，分类讨论：

- 不选第 i 个课程：$f[i]=f[i−1]$
- 选第 i 个课程：$f[i]=f[j]+T[i][2]$, 其中 j 是最大的满足 ，不存在时为 −1.

## 代码

```cpp
#include <bits/stdc++.h>
const int inf = 0x3f3f3f3f;
using i64 = long long;

void solve() {
    int n;
    std::cin >> n;
    std::array<int, 3> a[n];
    for (int i = 0; i < n; ++i) {
    	std::cin >> a[i][1] >> a[i][0] >> a[i][2];
    } 
    std::sort(a, a + n, [](auto &a, auto &b) { return a[0] < b[0]; }); 
    std::vector<int> f(n + 1);
    for (int i = 0; i < n; ++i) {
        int j = std::upper_bound(a, a + i, std::array<int, 3>{a[i][1], INT_MAX}) - a;
        f[i + 1] = std::max(f[i], f[j] + a[i][2]);
    }
    std::cout << f[n] << "\n";
}


int main() {
    std::cin.sync_with_stdio(false);
    std::cin.tie(0);
    
    solve();

    return 0;
}
```

